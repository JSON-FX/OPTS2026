# Story 4.2.4: Real-Time Notification Delivery with Laravel Reverb

**Status**: Draft
**Epic**: Epic 4.2 - Notification System Expansion
**Story Statement**: As a user, I want to see new notifications appear in the notification bell immediately without refreshing the page, so that I can respond to urgent items (overdue alerts, received transactions, completions) in real time.

---

## Acceptance Criteria

1. **Laravel Reverb WebSocket Server**: A WebSocket server is configured and running via Laravel Reverb:
   - `laravel/reverb` package installed and configured
   - `config/reverb.php` generated with sensible defaults
   - `.env.example` updated with all `REVERB_*` and `VITE_REVERB_*` environment variables
   - Reverb server starts with `php artisan reverb:start`

2. **Broadcasting Configuration**: Laravel broadcasting infrastructure is enabled:
   - `config/broadcasting.php` configured with `reverb` as default connection
   - `routes/channels.php` authorizes private user notification channels: `App.Models.User.{id}`
   - `BroadcastServiceProvider` registered (if not auto-discovered in Laravel 12)

3. **Notification Broadcasting**: All existing notification classes broadcast alongside database storage:
   - `TransactionReceivedNotification` — via `['database', 'broadcast']`
   - `TransactionCompletedNotification` — via `['database', 'broadcast']`
   - `TransactionOverdueNotification` — via `['database', 'broadcast']`
   - `OutOfWorkflowNotification` — via `['database', 'broadcast']`
   - Broadcast payload matches the `toArray()` output (no separate `toBroadcast()` needed)
   - Notifications implement `ShouldBroadcast` interface (or use the `broadcast` channel which handles it)

4. **Frontend Laravel Echo Setup**: Laravel Echo is initialized and connected to Reverb:
   - `laravel-echo` and `pusher-js` npm packages installed
   - Echo initialized in `resources/js/bootstrap.ts` with Reverb configuration
   - TypeScript type declarations added for `window.Echo` and `window.Pusher`
   - Connection uses environment variables (`VITE_REVERB_APP_KEY`, `VITE_REVERB_HOST`, `VITE_REVERB_PORT`, `VITE_REVERB_SCHEME`)

5. **NotificationBell Real-Time Updates**: The `NotificationBell.tsx` component updates live:
   - Listens on the authenticated user's private notification channel
   - When a new notification arrives via WebSocket:
     - Unread count badge increments immediately
     - New notification appears at the top of the recent list in the popover
     - No page reload or Inertia visit required
   - When user marks a notification as read, the count decrements (existing behavior, unchanged)

6. **Notifications Index Page**: The `Notifications/Index.tsx` page does NOT need real-time updates (users can refresh or rely on the bell badge). No changes required to this page.

7. **Graceful Degradation**: If the WebSocket connection fails or is unavailable:
   - The system falls back to existing behavior (notifications update on page navigation)
   - No console errors or UI breakage when Reverb is not running
   - Database notifications are always stored regardless of broadcast success

8. **Testing**:
   - Feature test: notification broadcast event is dispatched when each notification type is sent
   - Feature test: private channel authorization allows authenticated user, denies other users
   - Feature test: broadcast payload matches expected structure
   - Manual/E2E test: open two browser tabs — trigger a notification and verify it appears in the other tab's bell without refresh

---

## Tasks / Subtasks

- [ ] Task 1: Install and configure Laravel Reverb (AC: 1, 2)
  - [ ] Install `laravel/reverb` via Composer: `composer require laravel/reverb`
  - [ ] Run `php artisan reverb:install` to generate config and environment variables
  - [ ] Verify `config/reverb.php` is generated with correct defaults
  - [ ] Update `.env.example` with all `REVERB_*` variables and `VITE_REVERB_*` variables
  - [ ] Verify `config/broadcasting.php` exists and `reverb` connection is configured
  - [ ] Create/update `routes/channels.php` with private channel authorization:
    ```php
    Broadcast::channel('App.Models.User.{id}', function ($user, $id) {
        return (int) $user->id === (int) $id;
    });
    ```
  - [ ] Ensure `BroadcastServiceProvider` is registered in `bootstrap/app.php` or auto-discovered

- [ ] Task 2: Add broadcast channel to notification classes (AC: 3)
  - [ ] Update `OutOfWorkflowNotification` — change `via()` to return `['database', 'broadcast']`
  - [ ] Update `TransactionReceivedNotification` — change `via()` to return `['database', 'broadcast']`
  - [ ] Update `TransactionCompletedNotification` — change `via()` to return `['database', 'broadcast']`
  - [ ] Update `TransactionOverdueNotification` — change `via()` to return `['database', 'broadcast']`
  - [ ] Verify each notification class has `Queueable` trait (already present) for async broadcast
  - [ ] Write feature tests verifying broadcast events are dispatched

- [ ] Task 3: Install frontend packages and initialize Echo (AC: 4)
  - [ ] Install npm packages: `npm install laravel-echo pusher-js`
  - [ ] Add TypeScript type declarations for `window.Echo` and `window.Pusher` in `resources/js/types/` or a `.d.ts` file
  - [ ] Initialize Laravel Echo in `resources/js/bootstrap.ts`:
    ```typescript
    import Echo from 'laravel-echo';
    import Pusher from 'pusher-js';

    window.Pusher = Pusher;
    window.Echo = new Echo({
        broadcaster: 'reverb',
        key: import.meta.env.VITE_REVERB_APP_KEY,
        wsHost: import.meta.env.VITE_REVERB_HOST,
        wsPort: import.meta.env.VITE_REVERB_PORT ?? 80,
        wssPort: import.meta.env.VITE_REVERB_PORT ?? 443,
        forceTLS: (import.meta.env.VITE_REVERB_SCHEME ?? 'https') === 'https',
        enabledTransports: ['ws', 'wss'],
    });
    ```
  - [ ] Verify TypeScript compiles with `npx tsc --noEmit`

- [ ] Task 4: Update NotificationBell for real-time listening (AC: 5, 7)
  - [ ] Import `useEffect` and `useCallback` from React (if not already)
  - [ ] Add `useEffect` hook that subscribes to the private user channel on mount:
    ```typescript
    useEffect(() => {
        if (!window.Echo || !auth.user) return;

        const channel = window.Echo.private(`App.Models.User.${auth.user.id}`);

        channel.notification((notification: AppNotification) => {
            // Update local state: increment unread count, prepend to recent list
        });

        return () => {
            channel.stopListening('.Illuminate\\Notifications\\Events\\BroadcastNotificationCreated');
        };
    }, [auth.user?.id]);
    ```
  - [ ] Manage local notification state with `useState` for real-time updates (merge with Inertia shared props)
  - [ ] Handle graceful degradation: wrap Echo setup in try/catch, check `window.Echo` exists before subscribing
  - [ ] Verify bell badge updates immediately when a notification arrives

- [ ] Task 5: Write feature tests for broadcasting (AC: 8)
  - [ ] Test: private channel authorization — authenticated user can listen on their own channel
  - [ ] Test: private channel authorization — user cannot listen on another user's channel
  - [ ] Test: each notification class dispatches broadcast event when sent
  - [ ] Test: broadcast payload contains expected fields (type, message, transaction_id, etc.)
  - [ ] Test: graceful degradation — NotificationBell renders correctly without Echo connection

- [ ] Task 6: Verify TypeScript compilation and update documentation (AC: 1, 4)
  - [ ] Run `npx tsc --noEmit` to verify frontend compiles
  - [ ] Run `./vendor/bin/pint` for PHP formatting
  - [ ] Run all notification-related tests to ensure no regression
  - [ ] Update `.env.example` comments explaining Reverb configuration

---

## Dev Notes

### Existing Source Files to Modify

- **OutOfWorkflowNotification**: `app/Notifications/OutOfWorkflowNotification.php` — add `'broadcast'` to `via()` return array
- **TransactionReceivedNotification**: `app/Notifications/TransactionReceivedNotification.php` — add `'broadcast'` to `via()` return array
- **TransactionCompletedNotification**: `app/Notifications/TransactionCompletedNotification.php` — add `'broadcast'` to `via()` return array
- **TransactionOverdueNotification**: `app/Notifications/TransactionOverdueNotification.php` — add `'broadcast'` to `via()` return array
- **bootstrap.ts**: `resources/js/bootstrap.ts` — add Laravel Echo initialization
- **NotificationBell**: `resources/js/Components/NotificationBell.tsx` — add `useEffect` for real-time channel subscription
- **bootstrap/app.php**: May need to register `BroadcastServiceProvider`
- **.env.example**: Add Reverb environment variables

### New Files

- `config/reverb.php` — auto-generated by `php artisan reverb:install`
- `config/broadcasting.php` — auto-generated or created during Reverb install
- `routes/channels.php` — private channel authorization rules
- TypeScript declaration file for Echo/Pusher globals (e.g., `resources/js/types/echo.d.ts`)
- `tests/Feature/BroadcastNotificationTest.php` — broadcasting tests

### How Laravel Reverb Broadcasting Works

Laravel Reverb is a first-party WebSocket server for Laravel. When a notification includes the `broadcast` channel:

1. The notification's `toArray()` data is serialized as the broadcast payload
2. Laravel dispatches it to Reverb via the `reverb` broadcasting driver
3. Reverb pushes it to all connected clients listening on the user's private channel
4. Laravel Echo on the frontend receives the event and triggers the registered callback

**Private Channel Pattern:** `App.Models.User.{id}` — This is Laravel's convention for notification broadcasting. When using `Notification::send()` with the `broadcast` channel, Laravel automatically broadcasts to `private-App.Models.User.{notifiable_id}`.

### Laravel 12 Auto-Discovery

- Laravel 12 uses event auto-discovery — no `EventServiceProvider` registration needed
- Broadcasting channels defined in `routes/channels.php` are auto-loaded
- `BroadcastServiceProvider` may need explicit registration in `bootstrap/app.php` — verify during implementation

### Graceful Degradation Strategy

The NotificationBell component should:
1. Check if `window.Echo` exists before subscribing
2. Wrap channel subscription in try/catch
3. Fall back to Inertia shared props (existing behavior) when Echo is unavailable
4. Never block rendering if WebSocket connection fails

### Dependencies

- **Story 4.2.1** (Done): All notification types exist with `database` channel
- **Story 3.8** (Done): Notification infrastructure — `NotificationBell.tsx`, `HandleInertiaRequests` middleware, `NotificationController`
- **No database migrations required** — broadcasting uses existing `notifications` table

### Important Notes

- Reverb is Laravel's first-party WebSocket server — no external services needed (unlike Pusher)
- Reverb can be started alongside the main app: `php artisan reverb:start`
- For production, use Supervisor to keep Reverb running: see Laravel docs
- The `HandleInertiaRequests` middleware shared props continue to work — they provide the initial state on page load. Real-time updates supplement this with live pushes between page loads.
- Do NOT modify `Notifications/Index.tsx` — real-time updates are only for the bell component

### Testing

- **Test location**: `tests/Feature/BroadcastNotificationTest.php`
- **Testing framework**: PHPUnit with `RefreshDatabase` trait
- **Key assertions**: `Notification::assertSentTo()` with broadcast channel check, `Broadcast::assertDispatched()`
- **Manual E2E**: Open two browser tabs logged in as the same user. Trigger a notification (e.g., via tinker) and verify the bell updates in both tabs without refresh.
- **TypeScript**: Run `npx tsc --noEmit` to verify frontend compiles

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-20 | 1.0 | Initial story creation | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used
*(To be filled by dev agent)*

### Debug Log References
*(To be filled by dev agent)*

### Completion Notes List
*(To be filled by dev agent)*

### File List
*(To be filled by dev agent)*

---

## QA Results
*(To be filled by QA agent)*
